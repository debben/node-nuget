// Generated by CoffeeScript 1.10.0
(function() {
  var NUGET_EXE, NodeNuget, Queue, _, crypto, debounceCallback, es, et, fs, getAssemblyInformationalVersion, getFile, path, randomFilename, runCommand, vinyl;

  fs = require('fs');

  path = require('path');

  _ = require('underscore');

  Queue = require('queue-async');

  es = require('event-stream');

  et = require('elementtree');

  crypto = require('crypto');

  vinyl = require('vinyl-fs');

  require('shelljs/global');

  NUGET_EXE = path.resolve(path.join(__dirname, '../bin/NuGet.exe'));

  runCommand = function(command, arg) {
    var args;
    args = [NUGET_EXE, command, '"' + arg + '"'];
    if (process.platform !== 'win32') {
      args.unshift('mono');
    }
    return exec(args.join(' '));
  };

  debounceCallback = function(callback) {
    var debounced_callback;
    debounced_callback = function() {
      if (debounced_callback.was_called) {
        return;
      }
      debounced_callback.was_called = true;
      return callback.apply(null, Array.prototype.slice.call(arguments, 0));
    };
    return debounced_callback;
  };

  getFile = function(file, callback) {
    if (file.pipe) {
      return callback(null, file);
    }
    return vinyl.src(file).pipe(es.writeArray(function(err, files) {
      if (err) {
        return callback(err);
      }
      if (files.length === 0 || files.length > 1) {
        return callback(new Error("Expecting one file for " + file + ". Found " + files.length));
      }
      return callback(null, files[0]);
    }));
  };

  randomFilename = function() {
    return crypto.createHash('sha1').update(new Date().getTime().toString() + _.uniqueId()).digest('hex');
  };

  getAssemblyInformationalVersion = function() {
    var expr, fileContents;
    fileContents = fs.readFileSync('Properties/AssemblyInfo.cs', 'ucs2');
    expr = /AssemblyInformationalVersion\(\"((\d|\.)+)\"\)/;
    return fileContents.match(expr)[1];
  };

  module.exports = NodeNuget = (function() {
    function NodeNuget() {}

    NodeNuget.setApiKey = function(key, callback) {
      if (runCommand('setApiKey', key).code !== 0) {
        return callback(new Error('Failed to set API key'));
      }
      return callback();
    };

    NodeNuget.pack = function(file, callback) {
      return getFile(file, function(err, file) {
        if (err) {
          return callback(err);
        }
        return file.pipe(es.wait(function(err, data) {
          var files, item, missing_files, package_desc, package_id, package_path, package_version;
          if (err) {
            return callback(err);
          }
          package_desc = et.parse(data.toString());
          package_id = package_desc.findtext('./metadata/id') || package_desc.findtext('./PropertyGroup/AssemblyName');
          package_version = package_desc.findtext('./metadata/version') || getAssemblyInformationalVersion();
          files = (function() {
            var i, len, ref, ref1, results;
            ref = package_desc.findall('./files/file');
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              results.push(path.join(path.dirname(file.path), (ref1 = item.attrib) != null ? ref1.src : void 0));
            }
            return results;
          })();
          if ((missing_files = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = file.length; i < len; i++) {
              item = file[i];
              if (!fs.existsSync(item)) {
                results.push(item);
              }
            }
            return results;
          })()).length) {
            return callback(new Error("Nuget: cannot build " + file.path + ". Missing files: " + missing_files));
          }
          if (runCommand('pack', file.path).code !== 0) {
            return callback(new Error("Failed to pack file: " + file.path));
          }
          package_path = path.resolve(path.join(process.cwd(), '.', package_id + "." + package_version + ".nupkg"));
          return getFile(package_path, function(err, file) {
            if (err) {
              return callback(err);
            }
            return fs.unlink(package_path, function() {
              return callback(err, file);
            });
          });
        }));
      });
    };

    NodeNuget.push = function(file, callback) {
      var file_path, owned, queue;
      file_path = null;
      owned = false;
      queue = new Queue(1);
      queue.defer(function(callback) {
        if (!file.pipe) {
          return callback(null, file_path = file);
        }
        if (fs.existsSync(file_path = file.path)) {
          return callback();
        }
        callback = debounceCallback(callback);
        file_path = randomFilename();
        owned = true;
        return file.pipe(fs.createWriteStream(file_path)).on('finish', callback).on('error', callback);
      });
      queue.defer(function(callback) {
        if (runCommand('push', file_path).code !== 0) {
          return callback(new Error("Failed to push file: " + file.path));
        }
        return callback();
      });
      return queue.await(function(err) {
        if (file_path && owned && fs.existsSync(file_path)) {
          fs.unlinkSync(file_path);
        }
        return callback(err);
      });
    };

    return NodeNuget;

  })();

}).call(this);
